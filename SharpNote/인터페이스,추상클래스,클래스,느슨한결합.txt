
📘 C# 추상 클래스 vs 인터페이스 차이점 + Unity 인터페이스 이점

────────────────────────────────────────────
✅ 추상 클래스와 인터페이스의 차이점 (쉽게 설명)
────────────────────────────────────────────

🔷 추상 클래스 (abstract class)
- "공통 부모" 역할을 함.
- 기본 동작도 가지고 있고, 자식이 덮어쓰기도 가능함.
- 예: 동물(Animal)이라는 클래스에 '숨쉬기'는 공통으로 구현하고, '울음소리'는 자식이 다르게 구현함.

🔷 인터페이스 (interface)
- "기능 약속서" 역할을 함.
- 어떤 기능이 꼭 있어야 한다고 정해주는 규칙.
- 기본 동작은 없고, 구현은 자식 클래스가 다 함.
- 예: ISpeakable → "Speak() 함수는 꼭 있어야 해!" 라는 약속만 함.

📌 간단 비교표

| 항목             | 추상 클래스         | 인터페이스           |
|------------------|----------------------|------------------------|
| 기본 동작 구현    | 있음                 | 거의 없음 (C# 8 이상 예외) |
| 필드(변수) 사용   | 가능                 | 불가 (상수만 가능)       |
| 생성자 사용       | 가능                 | 불가                   |
| 다중 상속         | 불가 (하나만 가능)   | 가능 (여러 개 사용 가능) |
| 용도              | 부모 클래스 역할     | 기능 약속 / 규칙 정하기   |

────────────────────────────────────────────
✅ Unity에서 인터페이스를 쓰면 좋은 점 5가지
────────────────────────────────────────────

🎮 예시 인터페이스: IDamageable
```csharp
public interface IDamageable
{
    void TakeDamage(int amount);
}
```

🟡 1. **서로 다른 것들을 똑같이 다룰 수 있어요**
- 예: 몬스터, 보스, 상자, 함정 모두 '데미지를 입을 수 있어요' (IDamageable)
- 각각 다른 클래스지만 TakeDamage()만 있으면 하나로 묶을 수 있어요!

🟡 2. **유지보수가 쉬워요**
- 기능이 인터페이스로 묶여 있으면, 나중에 수정할 때 코드 바꾸기 쉬워요.
- 예: 모든 공격 가능한 객체는 IDamageable을 쓰면 됨!

🟡 3. **여러 개를 한꺼번에 쓸 수 있어요**
- C# 클래스는 부모를 하나만 가질 수 있지만,
- 인터페이스는 여러 개 동시에 사용 가능해요! (IRunnable, IDamageable, IInteractable 등)

🟡 4. **테스트하기가 쉬워요**
- 가짜 클래스(Mock)를 만들어서 게임 안 돌리고도 테스트 가능해요.
- 예: MockDamageable : IDamageable → 테스트 코드에서 사용

🟡 5. **코드를 예쁘고, 깔끔하게 만들 수 있어요**
- 코드가 역할별로 나뉘어서 읽기 쉽고, 협업할 때도 편해요.
- "이 클래스는 공격도 되고, 저장도 되고, 대화도 가능해!"라고 명확해짐.

────────────────────────────────────────────
✅ 마무리 요약
────────────────────────────────────────────

🔸 추상 클래스: 기본 동작도 포함된 부모 클래스
🔸 인터페이스: "이 기능 있어야 해!" 라고 알려주는 기능 약속서

🎮 Unity에서는 인터페이스를 활용하면 게임 오브젝트들을 기능 단위로 깔끔하게 나눌 수 있어요!
→ 유지보수, 테스트, 협업 모두 Good! 👍


────────────────────────────────────────────
✅ 추가: 인터페이스와 클래스의 차이점
────────────────────────────────────────────

🔷 클래스 (class)
- 상태(변수) + 동작(메서드)을 모두 가질 수 있는 '설계도'
- 객체를 만들기 위한 기본 단위
- new 키워드로 인스턴스 생성 가능

🔷 인터페이스 (interface)
- "이런 기능이 꼭 있어야 해!"라는 규칙을 정의하는 약속서
- 메서드나 속성의 '이름만' 정의하고 구현은 없음 (C# 8 이후 일부 구현 가능)
- 객체를 직접 만들 수 없음 (new로 사용 불가)
- 클래스나 구조체에서 구현해야 의미가 있음

📌 비교 표

| 항목             | 클래스 (class)                    | 인터페이스 (interface)                      |
|------------------|-----------------------------------|----------------------------------------------|
| 인스턴스 생성     | 가능 (`new`로 직접 생성 가능)     | 불가능 (구현 클래스 통해서만 가능)          |
| 변수(필드)        | 선언 및 사용 가능                 | 선언 불가 (상수만 허용)                      |
| 구현 내용         | 메서드, 생성자 등 구현 포함 가능 | 보통 구현 없음 (C# 8.0 이후 일부 허용)       |
| 상속 제한         | 단일 클래스만 상속 가능          | 다중 구현 가능                               |
| 용도              | 실제 객체를 만들기 위한 설계도   | 기능만 정의해두고, 구현은 클래스에 맡김      |

📌 한 줄 요약:
> 클래스는 '진짜 설계도'고, 인터페이스는 '기능 체크리스트'다!  
> 클래스는 만들어서 쓰고, 인터페이스는 구현해서 쓴다!

────────────────────────────────────────────
